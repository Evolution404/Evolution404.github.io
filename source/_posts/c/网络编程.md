---
title: 网络编程
date: 2020-08-22 12:37:06
tags:
- network
categories:
- c
---

## 基本函数和数据结构

### socket函数
```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```
* 成功时返回⽂件描述符,失败时返回-1
* domain: 套接字中使⽤的协议族(Protocol Family)
* type: 套接字数据传输的类型信息
* protocol: 计算机间通信使用的协议信息

#### 协议族(Protocol Family)

通过 socket 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类：

> 头文件 `sys/socket.h` 中声明的协议族

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPV4 互联网协议族    |
| PF_INET6  | IPV6 互联网协议族    |
| PF_LOCAL  | 本地通信 Unix 协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novel 协议族     |
这些名字中`PF = Protocol Family`,还有`AF = Address Family`这两个分别代表了协议族和地址族
协议族用于socket函数,地址族用于`sockaddr_in`结构体
`INET`就是`internet`的缩写

#### 套接字类型(type)
已经通过第一个参数传递了协议族信息,每个协议族还有各自的若干种数据传输方式,这些传输方式就由套接字类型表示
例如`PF_INET`就有`SOCK_STREAM`和`SOCK_DGRAM`两种传输方式

##### 面向连接的套接字(SOCK_STREAM)
如果 socket 函数的第二个参数传递`SOCK_STREAM`，将创建面向连接的套接字。

传输方式特征整理如下：

- 传输过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界（Boundary）

这种情形适用于之前说过的 write 和 read 函数

> 传输数据的计算机通过调用3次 write 函数传递了 100 字节的数据，但是接受数据的计算机仅仅通过调用 1 次 read 函数调用就接受了全部 100 个字节。

收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。

**套接字缓冲已满是否意味着数据丢失？**

> 答：缓冲并不总是满的。如果读取速度比数据传入过来的速度慢，则缓冲可能被填满，但是这时也不会丢失数据，因为传输套接字此时会停止数据传输，所以面向连接的套接字不会发生数据丢失。

套接字联机必须一一对应。面向连接的套接字可总结为：

**可靠地、按序传递的、基于字节的面向连接的数据传输方式的套接字。**
##### 面向消息的套接字(SOCK_DGRAM)
如果 socket 函数的第二个参数传递`SOCK_DGRAM`，则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车队。特点如下：

- 强调快速传输而非传输有序
- 传输的数据可能丢失也可能损毁
- 传输的数据有边界
- 限制每次传输数据的大小

面向消息的套接字比面向连接的套接字更具哟传输速度，但可能丢失。特点可总结为：

**不可靠的、不按序传递的、以数据的高速传输为目的套接字。**

#### 协议
如果同一协议族内存在多种传输方式相同的协议就需要传递这一参数
针对`PF_INET`协议族面向连接的套接字只有`IPPROTO_TCP`,面向消息的套接字只有`IPPROTO_UDP`
所以在创建套接字时第三个参数可以可以填写`IPPROTO_xxx`或者0
```c
// tcp套接字的创建方法
socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
socket(PF_INET, SOCK_STREAM, 0);
// udp套接字的创建方法
socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
socket(PF_INET, SOCK_DGRAM, 0);
```

### 地址信息sockaddr_in
该结构体的定义
```c
struct sockaddr_in
{
    sa_family_t sin_family;  //地址族（Address Family）
    uint16_t sin_port;       //16 位 TCP/UDP 端口号
    struct in_addr sin_addr; //32位 IP 地址
    char sin_zero[8];        //不使用
};
```
