<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="lua源码7-ltable解析"><meta name="keywords" content="c"><meta name="author" content="zhang Yuxi"><meta name="copyright" content="zhang Yuxi"><title>Evolution</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#table的结构"><span class="toc-number">1.</span> <span class="toc-text">table的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash系列宏"><span class="toc-number">2.</span> <span class="toc-text">hash系列宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列相关-findindex"><span class="toc-number">3.</span> <span class="toc-text">序列相关(findindex)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-free相关函数"><span class="toc-number">4.</span> <span class="toc-text">new,free相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaH-get系列"><span class="toc-number">5.</span> <span class="toc-text">luaH_get系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#luaH-getn-获取table的长度"><span class="toc-number">5.1.</span> <span class="toc-text">luaH_getn 获取table的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaH-set系列"><span class="toc-number">6.</span> <span class="toc-text">luaH_set系列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rehash"><span class="toc-number">7.</span> <span class="toc-text">Rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#computesizes"><span class="toc-number">7.1.</span> <span class="toc-text">computesizes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countint"><span class="toc-number">7.2.</span> <span class="toc-text">countint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#numusearray-numusehash"><span class="toc-number">7.3.</span> <span class="toc-text">numusearray numusehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-number">7.4.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setarrayvector-setnodevector"><span class="toc-number">7.5.</span> <span class="toc-text">setarrayvector setnodevector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#luaH-resize"><span class="toc-number">7.6.</span> <span class="toc-text">luaH_resize</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gitee.com/Evolution404/picgo-img/raw/master/20191026181121-HBhrfe.jpg"></div><div class="author-info__name text-center">zhang Yuxi</div><div class="author-info__description text-center">It is not our abilities that show what we truly are , it is our choices</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">91</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://evolution404.gitee.io/markdownimg/20190513125446.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Evolution</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">lua源码7-ltable解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-01-26<span class="post-meta__separator">|</span><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 更新于 2021-04-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/lua/">lua</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="table的结构"><a href="#table的结构" class="headerlink" title="table的结构"></a>table的结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">int</span> next;  <span class="comment">/* for chaining (offset for next node) */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of 'node' array */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sizearray;  <span class="comment">/* size of 'array' array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>
<p><strong>结构图</strong><br><img src="http://evolution404.gitee.io/markdownimg/006tNc79ly1fzk0mjhvfpj30p50ijwfr.jpg" alt></p>
<a id="more"></a>
<p><strong>Table</strong><br>分为<code>array</code>和<code>hash表</code>两部分</p>
<ol>
<li>array: 使用数组存储, 表示的是<code>Table</code>的数组部分</li>
<li>node: 表示<code>Table</code>的哈希表部分, 这个地址指向第一个桶</li>
<li>lastfree: 存放最后一个桶的地址</li>
</ol>
<p><strong>TKey</strong><br><a href="https://www.cnblogs.com/dingxiaoqiang/p/8059329.html" target="_blank" rel="noopener">结构体对齐</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TKey</span> &#123;</span></span><br><span class="line">  TValue tvk;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">&#125; TKey;</span><br></pre></td></tr></table></figure></p>
<p>可以这样存储, 但是为了对齐和节省空间, 使用了源码中的方式</p>
<p><code>TValue</code>是16个字节, 如果像上面那样定义的话<code>TKey</code>增加了4个字节又因为要按照8字节对齐所以是24字节<br>这样就浪费了因为对齐使用的4个字节<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">int</span> next;  <span class="comment">/* for chaining (offset for next node) */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br></pre></td></tr></table></figure></p>
<p>如果采用这样的定义方式, 总共需要16个字节<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields	Value value_; int tt_</span></span><br></pre></td></tr></table></figure></p>
<p>正好使用next占据了4个字节, 填补了浪费的对齐字节,<br>利用union的特点 <code>TValue</code>继续利用之前的12个字节,与原来是等价的<br>这样在访问<code>TValue</code>的时候依然是<code>k.tvk</code>, 只是获取next的时候需要<code>k.nk.next</code>,<br>不过这一点也被封装进了宏 <code>#define gnext(n)    ((n)-&gt;i_key.nk.next)</code></p>
<p><strong>Node</strong><br><code>Node</code>的定义就没什么好说的了, 定义了一个键值对</p>
<h2 id="hash系列宏"><a href="#hash系列宏" class="headerlink" title="hash系列宏"></a>hash系列宏</h2><p><strong>hashpow2</strong><br>hashpow2(t, n) t是table, n是hash值. 功能就是根据hash值得到table里哈希表对应的元素</p>
<p><strong>hashstr</strong><br>这个宏是针对短字符串的, 调用hashpow2, 传入的hash值就是<code>str-&gt;hash</code></p>
<p><strong>hashboolean, hashint</strong><br>hash值都是直接传入hashpow2, 没有什么多余操作</p>
<p><strong>hashmod</strong><br>hashmod(t,n) 与hashpow2功能类似,但是取余运算时2的指数的数减1,<br>由于指针等数据都和2的指数有关很容易冲突,所以利用这种方式来减少冲突</p>
<p><strong>hashpointer</strong><br>内部调用了<code>hashmod</code>传入的<code>hash</code>值是将指针强转成<code>uint</code>的值</p>
<h2 id="序列相关-findindex"><a href="#序列相关-findindex" class="headerlink" title="序列相关(findindex)"></a>序列相关(findindex)</h2><p><strong>主要功能</strong><br>输入<code>table</code>和<code>key</code>返回<code>value</code>的序号</p>
<ol>
<li>搜索<code>array</code>区域<br>利用<code>arrayindex</code>函数</li>
<li>搜索<code>hash</code>区域<br>利用<code>mainposition</code>函数, 得到桶内第一个元素<br>遍历这个链, 如果找不到直接<code>abort</code>退出<br>因为<code>luaG_runerror</code>中调用了<code>abort</code></li>
</ol>
<p>哈希部分的存储不是通常的桶结构, 是提前申请好的一个数组<br><code>next</code>代表的是下一个元素的相对位置</p>
<p><strong>arrayindex</strong><br>实质就是将<code>TValue</code>转化成一个<code>unsigned int</code>返回<br>不能转换就返回0</p>
<p><strong>mainposition</strong><br>针对不同的类型计算哈希值, 然后取得对应哈希值的桶的头<code>Node</code></p>
<h2 id="new-free相关函数"><a href="#new-free相关函数" class="headerlink" title="new,free相关函数"></a>new,free相关函数</h2><p><strong>luaH_new</strong><br>功能很简单就是创建一个表,<br><code>array</code>部分和<code>hash</code>部分大小都是0<br><strong>luaH_free</strong><br>释放<code>array</code>部分和<code>hash</code>部分的内存<br><strong>getfreepos</strong><br>从<code>lastfree</code>开始向前找一个key为nil的Node, 返回这个Node<br>如果找不到返回<code>NULL</code><br><strong>luaH_newkey</strong><br>流程图<br><img src="http://evolution404.gitee.io/markdownimg/006tNc79ly1fzm5bmyskrj30pe1070uh.jpg" alt></p>
<h2 id="luaH-get系列"><a href="#luaH-get系列" class="headerlink" title="luaH_get系列"></a>luaH_get系列</h2><p><strong>luaH_getint</strong><br><em>根据整数key返回t中的TValue</em><br>传入<code>lua_Integer key</code><br>如果<code>key</code>在<code>array</code>中返回<code>t-&gt;array[key-1]</code><br>如果<code>key</code>在<code>hash</code>中查询这条链, 找到返回值<br>找不到返回<code>luaO_nilobject</code> 这个全局共享的一个<code>TValue</code>地址</p>
<p><strong>luaH_getshortstr</strong><br>与<code>getint</code>类似, 但是不需要到<code>array</code>中进行查询<br>因为短字符串只会存在于<code>hash</code>部分</p>
<p><strong>getgeneric</strong><br>通用的get函数, 适用于只在<code>hash</code>部分进行查询的<code>TValue</code></p>
<p><strong>luaH_getstr</strong><br>综合了上面两个函数, 区分长短字符串分别进行查询</p>
<p><strong>luaH_get</strong></p>
<ol>
<li>shrstr: 直接调用<code>getshortstr</code>短字符串函数</li>
<li>numint: 直接调用<code>getint</code>函数</li>
<li>nil: 直接返回全局<code>nilobject</code></li>
<li>numflt: 如果可以转成整数使用<code>getint</code>, 否则调用<code>getgeneric</code></li>
<li>其余类型: 使用<code>getgeneric</code></li>
</ol>
<h3 id="luaH-getn-获取table的长度"><a href="#luaH-getn-获取table的长度" class="headerlink" title="luaH_getn 获取table的长度"></a>luaH_getn 获取table的长度</h3><p>获取table长度总共有三种情况</p>
<ol>
<li>有数组部分, 且数组最后一位是nil<br>这种情况对数组部分进行二分查找<br>例如<code>{1,nil,3,nil}</code>, j为右侧游标是数组长度4指向最后一个nil, i为0 指向隐藏位置0即1之前的位置(假设序号从1开始)<br>逐渐靠近最终i指向1,j指向1之后的nil,所以i为1返回i</li>
<li><p>没有数组部分或数组最后一位不是nil 并且不存在<code>hash</code>部分<br>很简单的操作直接返回数组size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> j;  <span class="comment">/* that is easy... */</span></span><br></pre></td></tr></table></figure>
<p><em>作者也是这么说(tu)的(cao)</em></p>
</li>
<li><p>没有数组部分或数组最后一位不是nil 且存在<code>hash</code>部分<br>这个也是二分查找, 不过初始i就是数组的size了, j是i加1之后的值<br>如果加1之后能够在hash部分查找到值的话就不断对j翻倍直到找到不能查找到值得一个j<br>现在i和j已经具备,继续按照上述的二分法查找<br>例如:<br> {1,nil,3,qs = 19891103}<br> i=3 j=4, j与i的差值小于1不需要二分直接返回i为3</p>
<p> {1,2,3,[4] = 4}<br> i=3 j=8  初始j=4由于获取4的值不为nil 变成8<br> i=3 j=5  (3+8)/2 为5 是nil j设置为5<br> i=4 j=5  (3+5)/2 为4 不是nil i设置为4<br> 相差为1直接返回i为4<br> 这个例子中我发现了[4]=4 实际的存储key类型就是整数,但是单独划分在了hash部分<br><a href="https://blog.csdn.net/ball32109/article/details/44904253" target="_blank" rel="noopener">详细解读</a></p>
</li>
</ol>
<h2 id="luaH-set系列"><a href="#luaH-set系列" class="headerlink" title="luaH_set系列"></a>luaH_set系列</h2><p><strong>luaH_set</strong><br>传入<code>TValue *key</code><br>返回这个key对应的value指针<br>如果不存在这个key就会新建key</p>
<p><strong>luaH_setint</strong><br>传入<code>lua_Integer key</code>和<code>TValue *value</code><br>在<code>table</code>中如果存在这个key就修改对应的值<br>否则就创建这个key,并设置value<br>创建是调用了<code>luaH_newkey</code></p>
<h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><h3 id="computesizes"><a href="#computesizes" class="headerlink" title="computesizes"></a>computesizes</h3><p><strong>参数解读</strong><br>传入两个参数<code>unsigned int nums[]</code> 和 <code>unsigned int *pna</code><br><code>nums[i]</code>中存储的是2^(i-1)到2^i之间表中元素的个数<br>例如一个表有<code>key</code> 1,2,3,20, 那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums[0] = 1(1落在此区间)</span><br><span class="line">nums[1] = 1(2落在此区间)</span><br><span class="line">nums[2] = 1(3落在此区间)</span><br><span class="line">nums[3] = 0</span><br><span class="line">nums[4] = 0</span><br><span class="line">nums[5] = 1(20落在此区间)</span><br><span class="line">nums[6] = 0</span><br></pre></td></tr></table></figure></p>
<p><code>*pna</code>是当前数组元素的个数<br><strong>函数功能</strong><br>返回一个最优值, 所谓最优值是<code>table</code>的数组部分的最优大小<br>  最优值满足以下条件:</p>
<ol>
<li>2的指数</li>
<li>元素占用率大于50%</li>
<li>满足前两个条件下的最大值<br>修改<code>pna</code>的值为当前的数组占用元素个数</li>
</ol>
<h3 id="countint"><a href="#countint" class="headerlink" title="countint"></a>countint</h3><p>这个函数就是用来提供<code>computesizes</code>中<code>nums</code>参数的<br>传入一个<code>key</code>如果这个<code>key</code>是整数型就对它向上取2的对数<br>在<code>nums</code>的相应位置加1<br>返回值: 1代表执行了操作, 0未进行操作</p>
<h3 id="numusearray-numusehash"><a href="#numusearray-numusehash" class="headerlink" title="numusearray numusehash"></a>numusearray numusehash</h3><p><strong>numusearray</strong><br>返回<code>array</code>部分的使用量, 设置<code>nums</code>数组的值</p>
<p><strong>numusehash</strong><br>返回<code>hash</code>部分的使用(非nil)数量<br>修改<code>*pna</code>的值为<code>hash</code>部分数字键的数量<br>修改<code>*nums</code>的数量</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p><strong>函数功能</strong><br>输入一个新key为<code>ek</code><br>对当前t的数组部分,哈希部分以及新加的<code>ek</code>重新统计<br><code>nums</code>数组各项值就是三个部分所有可以变成整数键的以2的指数阶梯统计的个数<br>  在<code>computesizes</code>中有介绍<br><code>na</code>就是所有可以存放到<code>array</code>部分的元素个数 <code>键可以转换成整数的元素</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compute new size for array part */</span></span><br><span class="line">asize = computesizes(nums, &amp;na);</span><br><span class="line"><span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">luaH_resize(L, t, asize, totaluse - na);</span><br></pre></td></tr></table></figure>
<p>接下来这两句,根据<code>nums</code>和<code>na</code>对数组部分进行最优计算, 得到新的<code>array</code>大小<br>更新<code>na</code>为<code>array</code>的使用量<br>最后重新分配数组和哈希部分的大小<br>数组大小: 显然是asize<br>哈希大小: 总使用量减去数组部分的使用量,<br>  可能会有疑问这样哈希部分不就没有余量了吗, 而且大小不一定满足2的指数?<br>  在<code>luaH_resize</code>中已经对哈希部分大小进行了处理, 如果不是2的指数向上取到最近的2的指数</p>
<h3 id="setarrayvector-setnodevector"><a href="#setarrayvector-setnodevector" class="headerlink" title="setarrayvector setnodevector"></a>setarrayvector setnodevector</h3><p><strong>setarrayvector</strong><br>这个就是对<code>t-&gt;array</code>重新分配内存, 修改<code>t-&gt;sizearray</code>的值<br>初始化分配的空间为<code>nil</code></p>
<p><strong>setnodevector</strong></p>
<ol>
<li>传入的size为0 将<code>t-&gt;node</code>设置为<code>dummynode</code> <code>lsizenode</code>为0, <code>lastfree</code>为<code>NULL</code></li>
<li>size不为0, 检测size是否越界, 是否超过2^MAXHBITS</li>
<li>分配内存并且将key, value都设置为nil</li>
<li>设置<code>lsizenode</code>为size, <code>lastfree</code>为第size个node<br>注意点:<br>如果传入size不是2的指数, 会被转换成2的指数<br>wgkey, gkey有区别,前者可以进行修改</li>
</ol>
<h3 id="luaH-resize"><a href="#luaH-resize" class="headerlink" title="luaH_resize"></a>luaH_resize</h3><p><strong>主要功能</strong><br>为table重新分配数组部分和哈希部分的大小<br><strong>流程</strong></p>
<ol>
<li>保存旧数组大小, 旧哈希大小, 旧哈希指针</li>
<li>如果数组部分扩大直接重新分配大小</li>
<li>重新分配哈希部分内存</li>
<li>如果数组部分缩小将缩小部分存到哈希部分, 之后重新分配数组内存</li>
<li>拷贝旧哈希值到新分配的空间</li>
<li>释放旧哈希部分空间</li>
</ol>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/28/lua/lua源码-lbaselib解析/"><i class="fa fa-chevron-left">  </i><span>lua源码8-lbaselib解析</span></a></div><div class="next-post pull-right"><a href="/2019/01/24/lua/lua源码6-lstring解析/"><span>lua源码6-lstring解析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span>评论</span></div><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'6gtOwA2GHt58meLiqVoE8cet-gzGzoHsz',
  appKey:'QpeNYt9Rb5S95BmN3fgBuRmi',
  placeholder:'留下你的足迹吧',
  avatar:'mp',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div></div><footer class="footer-bg" style="background-image: url(https://evolution404.gitee.io/markdownimg/20190513125446.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By zhang Yuxi</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-comments-o" id="to_comment"></i><i class="fa nightshift fa-moon-o" id="nightshift"></i></section><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/js.cookie.js"></script><script src="/js/search/local-search.js"></script><script src="/js/pace/pace.min.js"></script><script src="/js/nightshift/nightshift.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}
$("#to_comment").on("click", function() {
  var t = $("#post-comment").offset();
  $("body,html").animate({
    scrollTop: t.top
  })
})</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>